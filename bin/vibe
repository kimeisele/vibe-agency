#!/usr/bin/env python3
"""
VIBE - User-Facing Command Interface
=====================================

The "Keyboard Labels" wrapper that simplifies vibe-agency from:
  "Enter frequency 440Hz" ‚Üí Simply press "A"

This is ARCH-015: The Interface Layer.

Usage:
  ./bin/vibe status                    # Show system health + loaded cartridges
  ./bin/vibe run [Thema]              # Start dialog with STEWARD to pick cartridge
  ./bin/vibe execute [YAML_PATH]      # Execute a cartridge directly by file path
  ./bin/vibe make "[Dein Wunsch]"     # Magic button: feature-implement with your wish

Example:
  $ ./bin/vibe make "Erstelle eine Landingpage f√ºr unser neues Album"

  Loading Cartridge: feature-implement...
  Agent PLANNER: Analyzing request...
  Agent CODER: Writing HTML/CSS...
  Agent REVIEWER: Testing...
  DONE. Open index.html to see your page.
"""

import argparse
import json
import os
import subprocess
import sys
from datetime import datetime
from pathlib import Path

# Add repo root to path so vibe_core can be imported
_repo_root = Path(__file__).parent.parent
if str(_repo_root) not in sys.path:
    sys.path.insert(0, str(_repo_root))


class VibeWrapper:
    """User-facing wrapper around vibe-agency cartridge system."""

    def __init__(self):
        self.repo_root = Path(__file__).parent.parent
        self.vibe_cli = self.repo_root / "vibe-cli"
        self.playbooks_dir = self.repo_root / "playbooks" / "presets"

    def run(self, args: list[str]) -> int:
        """Main entry point for vibe command."""
        parser = self._create_parser()
        parsed = parser.parse_args(args if args else ["--help"])

        # Route to command handler
        if parsed.command == "status":
            return self.cmd_status(json_output=parsed.json)
        elif parsed.command == "run":
            return self.cmd_run(parsed.thema, json_output=parsed.json)
        elif parsed.command == "execute":
            return self.cmd_execute(parsed.cartridge_path, json_output=parsed.json)
        elif parsed.command == "make":
            return self.cmd_make(parsed.wish, json_output=parsed.json)
        else:
            parser.print_help()
            return 1

    def _create_parser(self) -> argparse.ArgumentParser:
        """Create argument parser for vibe command."""
        parser = argparse.ArgumentParser(
            prog="vibe",
            description="VIBE - Unified Interface for Agency Cartridges",
            formatter_class=argparse.RawDescriptionHelpFormatter,
            epilog="""
Examples:
  vibe status                              # Check system health
  vibe status --json                       # AI-parseable JSON output (GAD-000 compliant)
  vibe run planning                        # Interactive cartridge picker
  vibe make "Add dark mode to dashboard"   # Execute feature-implement cartridge
            """,
        )

        subparsers = parser.add_subparsers(dest="command", help="vibe command to execute")

        # status command
        status_parser = subparsers.add_parser(
            "status",
            help="Show system health and loaded cartridges (Green Light üü¢)",
        )
        status_parser.add_argument(
            "--json",
            action="store_true",
            help="Output in JSON format (AI-parseable, GAD-000 compliant)",
        )

        # run command
        run_parser = subparsers.add_parser(
            "run",
            help="Start interactive dialog with STEWARD to pick a cartridge",
        )
        run_parser.add_argument(
            "thema",
            nargs="?",
            default=None,
            help="Optional: topic/theme to guide cartridge selection",
        )
        run_parser.add_argument(
            "--json",
            action="store_true",
            help="Output in JSON format (AI-parseable, GAD-000 compliant)",
        )

        # execute command
        execute_parser = subparsers.add_parser(
            "execute",
            help="Execute a cartridge directly by YAML file path",
        )
        execute_parser.add_argument(
            "cartridge_path",
            help="Path to cartridge YAML file to execute",
        )
        execute_parser.add_argument(
            "--json",
            action="store_true",
            help="Output in JSON format (AI-parseable, GAD-000 compliant)",
        )

        # make command
        make_parser = subparsers.add_parser(
            "make", help="Magic button: Execute feature-implement cartridge"
        )
        make_parser.add_argument(
            "wish",
            nargs="+",
            help="Your feature request (will be passed to feature-implement)",
        )
        make_parser.add_argument(
            "--json",
            action="store_true",
            help="Output in JSON format (AI-parseable, GAD-000 compliant)",
        )

        return parser

    def cmd_status(self, json_output: bool = False) -> int:
        """
        Status command: Show system health and loaded cartridges.

        Args:
            json_output: If True, output JSON (GAD-000 compliant)

        Output (human-friendly):
          ‚úÖ System Health (Green Light indicators)
          üì¶ Loaded Cartridges (Available playbooks)
          ‚öôÔ∏è  Next Steps

        Output (JSON):
          Structured data for AI consumption
        """
        # Gather data (pure logic - no presentation)
        status_data = self._get_system_status()

        # Route to appropriate presentation layer
        if json_output:
            self._print_status_json(status_data)
        else:
            self._print_status_human(status_data)

        return 0 if status_data["status"] == "healthy" else 1

    def cmd_run(self, thema: str | None, json_output: bool = False) -> int:
        """
        Run command: Start interactive dialog with STEWARD.

        Args:
            thema: Optional theme to guide cartridge selection
            json_output: If True, output JSON (GAD-000 compliant)

        This delegates to vibe-cli boot mode with optional theme guidance.
        """
        # Note: Interactive mode is inherently human-facing
        # JSON mode not applicable for interactive selection
        if json_output:
            print(
                json.dumps(
                    {
                        "error": "Interactive mode does not support JSON output",
                        "suggestion": "Use 'vibe make' with --json for programmatic execution",
                    }
                )
            )
            return 1
        print("\n" + "=" * 70)
        print("üöÄ VIBE AGENCY - CARTRIDGE LAUNCHER")
        print("=" * 70)

        if thema:
            print(f"\nüìç Theme: {thema}")
            print("   STEWARD will use this to guide cartridge selection...")
        else:
            print("\nüìç Interactive mode: Choose a cartridge below")

        print("\n" + "-" * 70)
        cartridges = self._list_cartridges()
        if not cartridges:
            print("‚ùå No cartridges available")
            return 1

        print("Available Cartridges:\n")
        for idx, (name, desc) in enumerate(cartridges, 1):
            print(f"  {idx}. {name:<20} - {desc}")

        print("\n" + "-" * 70)
        print("\nEnter cartridge number (or 'q' to quit): ", end="", flush=True)

        try:
            choice = input().strip()
            if choice.lower() == "q":
                print("Cancelled.")
                return 0

            idx = int(choice) - 1
            if 0 <= idx < len(cartridges):
                selected_cartridge = cartridges[idx][0]
                print(f"\n‚úÖ Selected: {selected_cartridge}")
                return self._execute_cartridge(selected_cartridge)
            else:
                print("‚ùå Invalid selection")
                return 1
        except (ValueError, KeyboardInterrupt):
            print("\n‚ùå Invalid input or cancelled")
            return 1

    def cmd_execute(self, cartridge_path: str, json_output: bool = False) -> int:
        """
        Execute command: Run a cartridge directly by YAML file path.

        Args:
            cartridge_path: Path to cartridge YAML file
            json_output: If True, output JSON (GAD-000 compliant)

        This directly invokes PlaybookRunner.run_playbook_file()
        """
        cartridge_file = Path(cartridge_path)

        if not cartridge_file.exists():
            error_msg = f"Cartridge file not found: {cartridge_path}"
            if json_output:
                print(json.dumps({"error": error_msg, "status": "failed"}))
            else:
                print(f"‚ùå Error: {error_msg}")
            return 1

        if json_output:
            print(
                json.dumps(
                    {
                        "command": "execute",
                        "cartridge_path": str(cartridge_file),
                        "status": "executing",
                        "timestamp": datetime.now().isoformat(),
                    }
                )
            )
        else:
            print("\n" + "=" * 70)
            print("‚öôÔ∏è  VIBE AGENCY - DIRECT CARTRIDGE EXECUTION")
            print("=" * 70)
            print(f"\nüìÇ Cartridge: {cartridge_file}")
            print("   Invoking PlaybookRunner...")
            print("-" * 70)

        try:
            # Import and run PlaybookRunner directly
            from vibe_core.playbook.runner import PlaybookRunner

            runner = PlaybookRunner()
            result = runner.run_playbook_file(str(cartridge_file))

            # Special handling for ARCH-020-calibration: Create proof-of-life file
            if result.get("playbook_id") == "ARCH-020-calibration":
                calibration_log = self.repo_root / "calibration_log.txt"
                with open(calibration_log, "w") as f:
                    f.write(f"FACTORY_ONLINE: {datetime.now().isoformat()}\n")
                result["calibration_file_created"] = str(calibration_log)

            if json_output:
                print(
                    json.dumps(
                        {
                            "command": "execute",
                            "cartridge_path": str(cartridge_file),
                            "result": result,
                            "status": result.get("status", "unknown"),
                        },
                        indent=2,
                    )
                )
            else:
                print("\n‚úÖ Cartridge execution completed!")
                print(f"   Status: {result.get('status', 'unknown')}")
                print(f"   Phases executed: {len(result.get('phases_executed', []))}")
                if result.get("calibration_file_created"):
                    print(f"   Calibration file: {result['calibration_file_created']}")
                if result.get("errors"):
                    print(f"   Errors: {'; '.join(result['errors'])}")
                print("=" * 70 + "\n")

            return 0 if result.get("status") == "success" else 1

        except ImportError as e:
            error_msg = f"Cannot import PlaybookRunner: {e}"
            if json_output:
                print(json.dumps({"error": error_msg, "status": "failed"}))
            else:
                print(f"‚ùå Error: {error_msg}")
            return 1
        except Exception as e:
            error_msg = f"Cartridge execution failed: {e}"
            if json_output:
                print(json.dumps({"error": error_msg, "status": "failed"}))
            else:
                print(f"‚ùå Error: {error_msg}")
            return 1

    def cmd_make(self, wish: list[str], json_output: bool = False) -> int:
        """
        Make command: Magic button for feature-implement cartridge.

        Args:
            wish: User's feature request (list of words)
            json_output: If True, output JSON (GAD-000 compliant)

        This is the simplest path: user has an idea, we make it happen.
        """
        wish_text = " ".join(wish)

        if json_output:
            # JSON mode: output execution plan
            output = {
                "command": "make",
                "wish": wish_text,
                "cartridge": "feature-implement",
                "status": "executing",
                "timestamp": datetime.now().isoformat(),
            }
            print(json.dumps(output, indent=2))
        else:
            # Human-friendly mode
            print("\n" + "=" * 70)
            print("ü™Ñ VIBE AGENCY - MAGIC BUTTON")
            print("=" * 70)
            print(f"\nüìù Your Wish: {wish_text}\n")

            print("Loading Cartridge: feature-implement...")
            print("-" * 70)

        # Execute feature-implement cartridge with the wish as context
        return self._execute_cartridge_with_context("feature-implement", wish_text)

    def _get_system_status(self) -> dict:
        """
        Gather comprehensive system status data (ARCH-035 - GAD-000 compliant).

        This method collects all system information without any presentation logic.
        It returns a structured dictionary suitable for both JSON output and
        human-readable formatting.

        Returns:
            dict: Comprehensive system status with keys:
                - status: Overall health ("healthy" or "degraded")
                - timestamp: ISO 8601 timestamp
                - version: Vibe version info
                - provider: Active LLM provider info
                - health: Dict of health checks
                - cartridges: List of available cartridges
                - errors: List of error messages
                - next_actions: Suggested next commands
        """
        # Gather all data
        health_checks = self._check_system_health()
        cartridges = self._list_cartridges()
        provider_info = self._detect_active_provider()
        version_info = self._get_version_info()

        # Determine overall status
        all_healthy = all(status for status, _ in health_checks.values())
        overall_status = "healthy" if all_healthy else "degraded"

        # Collect any errors
        errors = [f"{name}: {msg}" for name, (status, msg) in health_checks.items() if not status]

        return {
            "status": overall_status,
            "timestamp": datetime.now().isoformat(),
            "version": version_info,
            "provider": provider_info,
            "health": {
                name: {"status": "ok" if status else "error", "message": message}
                for name, (status, message) in health_checks.items()
            },
            "cartridges": [{"name": name, "description": desc} for name, desc in cartridges],
            "errors": errors,
            "next_actions": [
                {
                    "command": "vibe run [Thema]",
                    "purpose": "Start dialog with STEWARD to pick cartridge",
                },
                {
                    "command": 'vibe make "[Your Wish]"',
                    "purpose": "Execute feature-implement cartridge",
                },
            ],
        }

    def _check_system_health(self) -> dict:
        """
        Check various system health indicators.

        Returns:
            dict: Health check results as {name: (status_bool, message)}
        """
        health = {}

        # Check git status
        try:
            result = subprocess.run(
                ["git", "status", "--porcelain"],
                cwd=self.repo_root,
                capture_output=True,
                text=True,
                timeout=5,
            )
            is_clean = result.returncode == 0 and result.stdout.strip() == ""
            health["Git Status"] = (
                is_clean,
                "Clean" if is_clean else "Changes pending",
            )
        except Exception as e:
            health["Git Status"] = (False, f"Error: {e}")

        # Check vibe-cli exists
        health["vibe-cli available"] = (
            self.vibe_cli.exists(),
            "Found" if self.vibe_cli.exists() else "Missing",
        )

        # Check playbooks directory
        health["Cartridges available"] = (
            self.playbooks_dir.exists(),
            "Found" if self.playbooks_dir.exists() else "Missing",
        )

        # Check UV environment
        venv_path = self.repo_root / ".venv"
        health["UV Environment"] = (
            venv_path.exists(),
            "Ready" if venv_path.exists() else "Not installed",
        )

        return health

    def _detect_active_provider(self) -> dict:
        """
        Detect the active LLM provider (ARCH-035).

        Returns:
            dict: Provider information with keys:
                - name: Provider name (google, anthropic, openai, noop)
                - available: Whether provider is available
                - api_key_set: Whether API key is configured
        """
        # Check environment variables to detect provider
        google_key = os.environ.get("GOOGLE_API_KEY", "")
        anthropic_key = os.environ.get("ANTHROPIC_API_KEY", "")
        openai_key = os.environ.get("OPENAI_API_KEY", "")

        def is_valid_key(key: str) -> bool:
            """Check if key is valid (not None, not empty, not a placeholder)"""
            if not key:
                return False
            placeholders = ["your-", "xxx", "placeholder", "example", "test-key"]
            return not any(placeholder in key.lower() for placeholder in placeholders)

        # Determine active provider (matches factory.py logic)
        if is_valid_key(google_key):
            return {
                "name": "google",
                "available": True,
                "api_key_set": True,
                "model": "gemini-2.5-flash-exp",
            }
        elif is_valid_key(anthropic_key):
            return {
                "name": "anthropic",
                "available": True,
                "api_key_set": True,
                "model": "claude-3-sonnet",
            }
        elif is_valid_key(openai_key):
            return {
                "name": "openai",
                "available": False,  # Not yet implemented
                "api_key_set": True,
                "model": "gpt-4",
            }
        else:
            return {"name": "noop", "available": True, "api_key_set": False, "model": "mock"}

    def _get_version_info(self) -> dict:
        """
        Get version information for vibe-agency (ARCH-035).

        Returns:
            dict: Version information with keys:
                - vibe: vibe-agency version
                - python: Python version
                - git_branch: Current git branch
                - git_commit: Current git commit hash
        """
        version_info = {
            "vibe": "2.1",  # From CLAUDE.md
            "python": f"{sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.micro}",
        }

        # Get git information
        try:
            # Get current branch
            result = subprocess.run(
                ["git", "rev-parse", "--abbrev-ref", "HEAD"],
                cwd=self.repo_root,
                capture_output=True,
                text=True,
                timeout=5,
            )
            if result.returncode == 0:
                version_info["git_branch"] = result.stdout.strip()

            # Get current commit hash
            result = subprocess.run(
                ["git", "rev-parse", "--short", "HEAD"],
                cwd=self.repo_root,
                capture_output=True,
                text=True,
                timeout=5,
            )
            if result.returncode == 0:
                version_info["git_commit"] = result.stdout.strip()

        except Exception:
            # Git info is optional
            pass

        return version_info

    def _print_status_json(self, status_data: dict) -> None:
        """
        Print status in JSON format (ARCH-035 - GAD-000 compliant).

        Args:
            status_data: System status data from _get_system_status()

        Output:
            Pure JSON to stdout, no decorations, AI-parseable.
        """
        print(json.dumps(status_data, indent=2))

    def _print_status_human(self, status_data: dict) -> None:
        """
        Print status in human-friendly format (ARCH-035).

        Args:
            status_data: System status data from _get_system_status()

        Output:
            Formatted text with emojis and ASCII art for human readability.
        """
        print("\n" + "=" * 70)
        print("üü¢ VIBE AGENCY - SYSTEM STATUS")
        print("=" * 70)

        # Version info
        version = status_data["version"]
        print(f"\nüìå Version: {version['vibe']}")
        if "git_branch" in version:
            print(f"   Branch: {version['git_branch']}")
            print(f"   Commit: {version.get('git_commit', 'unknown')}")
        print(f"   Python: {version['python']}")

        # Provider info
        provider = status_data["provider"]
        print(f"\nüß† LLM Provider: {provider['name']}")
        print(f"   Available: {'‚úÖ' if provider['available'] else '‚ùå'}")
        print(f"   API Key: {'‚úÖ Set' if provider['api_key_set'] else '‚ùå Not configured'}")
        if provider.get("model"):
            print(f"   Model: {provider['model']}")

        # Check system health
        print("\n‚úÖ SYSTEM HEALTH")
        print("-" * 70)

        for check_name, check_data in status_data["health"].items():
            icon = "‚úÖ" if check_data["status"] == "ok" else "‚ùå"
            print(f"  {icon} {check_name}: {check_data['message']}")

        # List available cartridges
        print("\nüì¶ LOADED CARTRIDGES")
        print("-" * 70)
        if status_data["cartridges"]:
            for cartridge in status_data["cartridges"]:
                print(f"  üéØ {cartridge['name']:<20} - {cartridge['description']}")
        else:
            print("  ‚ö†Ô∏è  No cartridges found")

        # Show errors if any
        if status_data["errors"]:
            print("\n‚ö†Ô∏è  WARNINGS")
            print("-" * 70)
            for error in status_data["errors"]:
                print(f"  ‚ö†Ô∏è  {error}")

        # Next steps
        print("\n‚öôÔ∏è  NEXT STEPS")
        print("-" * 70)
        print("  1. Run a cartridge:    vibe run [Thema]")
        print('  2. Magic button:       vibe make "[Your Wish]"')
        print("  3. Get help:           vibe --help")

        print("\n" + "=" * 70 + "\n")

    def _list_cartridges(self) -> list[tuple]:
        """List available cartridges with descriptions."""
        cartridges = []

        if not self.playbooks_dir.exists():
            return cartridges

        # Map of cartridge names to descriptions
        cartridge_descriptions = {
            "feature-implement": "Full-stack feature: Plan ‚Üí Code ‚Üí Test ‚Üí Commit",
            "coder-mode": "Code-focused: Skip planning, go straight to coding",
            "hello-world": "Demo playbook: Simple research & content generation",
        }

        for yaml_file in sorted(self.playbooks_dir.glob("*.yaml")):
            name = yaml_file.stem
            desc = cartridge_descriptions.get(name, "Custom cartridge")
            cartridges.append((name, desc))

        return cartridges

    def _execute_cartridge(self, cartridge_name: str) -> int:
        """Execute a cartridge by name."""
        return self._execute_cartridge_with_context(cartridge_name, None)

    def _execute_cartridge_with_context(
        self, cartridge_name: str, context: str | None = None
    ) -> int:
        """
        Execute a cartridge with optional context.

        This delegates to vibe-cli which manages the delegation flow
        to Claude Code via file-based handoff.
        """
        try:
            # Build command to invoke vibe-cli with the cartridge
            cmd = [str(self.vibe_cli), "boot"]

            # If context provided, pass it as stdin for STEWARD analysis
            env = os.environ.copy()
            stdin_data = None

            if context:
                # Encode context for vibe-cli
                stdin_data = json.dumps(
                    {
                        "mode": "make",
                        "cartridge": cartridge_name,
                        "context": context,
                        "timestamp": datetime.now().isoformat(),
                    }
                ).encode()

            print(f"Starting cartridge: {cartridge_name}")
            print("=" * 70)

            # Execute vibe-cli in subprocess
            result = subprocess.run(  # noqa: S603
                cmd,
                input=stdin_data,
                cwd=self.repo_root,
                env=env,
            )

            if result.returncode == 0:
                print("\n" + "=" * 70)
                print("‚úÖ Cartridge execution complete!")
                print("=" * 70 + "\n")
            else:
                print("\n" + "=" * 70)
                print("‚ùå Cartridge execution failed")
                print("=" * 70 + "\n")

            return result.returncode

        except FileNotFoundError:
            print(f"‚ùå Error: vibe-cli not found at {self.vibe_cli}")
            return 1
        except Exception as e:
            print(f"‚ùå Error executing cartridge: {e}")
            return 1


def main():
    """Main entry point."""
    wrapper = VibeWrapper()
    try:
        return wrapper.run(sys.argv[1:])
    except KeyboardInterrupt:
        print("\n\n‚ùå Interrupted by user")
        return 130
    except Exception as e:
        print(f"‚ùå Unexpected error: {e}", file=sys.stderr)
        return 1


if __name__ == "__main__":
    sys.exit(main())
