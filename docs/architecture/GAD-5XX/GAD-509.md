# GAD-509: Circuit Breaker Protocol

**Version:** 1.0  
**Status:** ✅ Implemented  
**Location:** `agency_os/00_system/runtime/circuit_breaker.py`

---

## Executive Summary

Protects VIBE Agency OS from **cascading failures** when LLM APIs are degraded. Implements a 3-state finite state machine (CLOSED → OPEN → HALF_OPEN) that automatically:

- **Detects degradation:** 5 failures within 60 seconds
- **Blocks requests:** Rejects calls when API is failing (prevents cascading)
- **Tests recovery:** Probes API health after 30-second timeout
- **Provides visibility:** Tracks metrics and state transitions

**Key Insight:** "Final Straw Defense" — stops infinite retry loops that consume costs and resources.

---

## Problem Statement

Without circuit breaking, degraded APIs cause:

1. **Cascading failures** — One failed API spawns dozens of retry attempts
2. **Resource waste** — System exhausts tokens/costs fighting a broken API
3. **Poor user experience** — Timeouts compound as retries stack
4. **No recovery signal** — System has no way to know when API recovers

**Example:** Anthropic API rate-limited → All tasks retry → All retries rate-limited → Timeout cascade → System collapse.

---

## Solution: 3-State Machine

### State Diagram

```
CLOSED (healthy)
    ↓ (5 failures/60s)
OPEN (failing)
    ↓ (30s timeout)
HALF_OPEN (testing)
    ↓ (probe succeeds)
CLOSED
```

### State Definitions

| State | Behavior | Entry Condition | Exit Condition |
|-------|----------|-----------------|----------------|
| **CLOSED** | All requests pass through | Initial state or probe success | 5 failures in 60s |
| **OPEN** | Requests rejected immediately | Failure threshold exceeded | 30s recovery timeout |
| **HALF_OPEN** | Allows one probe request | Recovery timeout elapsed | Probe succeeds → CLOSED, or fails → back to OPEN |

---

## Configuration

```python
@dataclass
class CircuitBreakerConfig:
    failure_threshold: int = 5              # Failures before opening
    recovery_timeout_seconds: int = 30      # Wait before probe
    window_size_seconds: int = 60           # Rolling window
    success_threshold_half_open: int = 1    # Successes to close from HALF_OPEN
```

### Defaults

| Parameter | Default | Meaning |
|-----------|---------|---------|
| `failure_threshold` | 5 | Circuit opens on 5 failures |
| `recovery_timeout_seconds` | 30 | Wait 30s before testing recovery |
| `window_size_seconds` | 60 | 60-second rolling failure window |
| `success_threshold_half_open` | 1 | 1 successful probe closes circuit |

---

## State Transitions

### CLOSED → OPEN

**Trigger:** Failure count ≥ 5 within rolling 60-second window

**Mechanism:**
```python
def _record_failure(self, error: Exception):
    self.failure_times.append(time.time())
    
    # Remove old failures outside the window
    window_start = time.time() - self.config.window_size_seconds
    self.failure_times = [t for t in self.failure_times if t >= window_start]
    self.failure_count = len(self.failure_times)
    
    if self.failure_count >= self.config.failure_threshold:
        self._transition_to(CircuitBreakerState.OPEN)
```

**Logged as:** ERROR level  
**System behavior:** All new requests raise `CircuitBreakerOpenError` immediately

---

### OPEN → HALF_OPEN

**Trigger:** `recovery_timeout_seconds` (30s) elapse since circuit opened

**Mechanism:**
```python
def can_execute(self) -> tuple[bool, str]:
    if self.state == CircuitBreakerState.OPEN:
        elapsed = time.time() - self.last_failure_time
        
        if elapsed > self.config.recovery_timeout_seconds:
            self._transition_to(CircuitBreakerState.HALF_OPEN)
            return True, "Transitioning to HALF_OPEN after recovery timeout"
```

**Automatic:** No manual intervention required  
**Logged as:** INFO level

---

### HALF_OPEN → CLOSED or OPEN

**If probe succeeds (HALF_OPEN → CLOSED):**
```python
def _record_success(self):
    if self.state == CircuitBreakerState.HALF_OPEN:
        logger.info("Probe succeeded - transitioning to CLOSED")
        self._transition_to(CircuitBreakerState.CLOSED)
        self.failure_count = 0
        self.failure_times.clear()
```

**If probe fails (HALF_OPEN → OPEN):**
- Probe request raises exception
- Failure recorded
- Circuit transitions back to OPEN

---

## Preventing Cascading Failures

### Mechanism 1: Fast-Fail

When OPEN, requests rejected immediately:

```python
def call(self, func, *args, **kwargs):
    can_execute, reason = self.can_execute()
    if not can_execute and self.state == CircuitBreakerState.OPEN:
        raise CircuitBreakerOpenError(
            f"Circuit breaker OPEN. Last error: {self.last_failure_error}"
        )
```

**Benefit:** No wasted retries on broken API

### Mechanism 2: Recovery Timeout

30-second timeout between OPEN → HALF_OPEN:

```python
recovery_timeout_seconds = 30  # Gives API time to recover
```

**Benefit:** Prevents immediate re-attempts (gives infrastructure time to stabilize)

### Mechanism 3: Probe Testing

One request in HALF_OPEN state:

```python
if self.state == CircuitBreakerState.HALF_OPEN:
    return True, "HALF_OPEN - probe request"
```

**Benefit:** Gracefully tests recovery without full traffic

---

## Metrics & Monitoring

```python
@dataclass
class CircuitBreakerMetrics:
    total_requests: int = 0
    successful_requests: int = 0
    failed_requests: int = 0
    rejected_requests: int = 0  # Rejected while OPEN
    state_changes: list[tuple[str, str]] = field(default_factory=list)
    last_failure_time: datetime | None = None
    last_failure_error: str | None = None
```

### Status Reporting

```python
def get_status(self) -> dict:
    return {
        "state": self.state.value,           # "closed", "open", "half_open"
        "failure_count": self.failure_count,  # Current failures in window
        "failure_threshold": self.config.failure_threshold,
        "last_failure_time": self.last_failure_time,
        "last_failure_error": self.last_failure_error,
        "metrics": {
            "total_requests": self.metrics.total_requests,
            "successful_requests": self.metrics.successful_requests,
            "failed_requests": self.metrics.failed_requests,
            "rejected_requests": self.metrics.rejected_requests,  # Blocked while OPEN
            "state_changes": len(self.metrics.state_changes),
        },
    }
```

---

## Exceptions

```python
class CircuitBreakerOpenError(Exception):
    """Raised when circuit is OPEN and request rejected"""
    
class CircuitBreakerHalfOpenError(Exception):
    """Raised when circuit is HALF_OPEN and non-probe request rejected"""
```

---

## Usage Pattern

### Basic Usage

```python
from agency_os.00_system.runtime.circuit_breaker import (
    CircuitBreaker,
    CircuitBreakerConfig,
    CircuitBreakerOpenError,
)

# Initialize breaker
breaker = CircuitBreaker(
    config=CircuitBreakerConfig(
        failure_threshold=5,
        recovery_timeout_seconds=30,
        window_size_seconds=60,
    )
)

# Use to protect API calls
try:
    result = breaker.call(
        llm_client.invoke,
        prompt="What is 2+2?",
        model="claude-3-5-sonnet",
    )
except CircuitBreakerOpenError as e:
    # API is down - use fallback
    logger.error(f"API degraded: {e}")
    result = use_cached_response()
```

### Monitoring

```python
# Check status
status = breaker.get_status()

if status["state"] == "open":
    logger.warning(f"Circuit OPEN: {status['last_failure_error']}")
    print(f"Will retry in {30}s")
    
elif status["state"] == "half_open":
    logger.info("Testing recovery with probe request")
    
else:  # closed
    print(f"Health: {status['successful_requests']} succeeds, "
          f"{status['failed_requests']} fails")
```

### Manual Reset (testing/recovery)

```python
breaker.reset()  # Force back to CLOSED (for testing or manual recovery)
```

---

## Integration with LLM Client

The `LLMClient` wraps all provider invocations:

```python
# From agency_os/00_system/runtime/llm_client.py

class LLMClient:
    def __init__(self, budget_limit=None, provider=None):
        self.circuit_breaker = CircuitBreaker(
            config=CircuitBreakerConfig(
                failure_threshold=5,
                recovery_timeout_seconds=30,
                window_size_seconds=60,
            )
        )
        self.provider = provider or get_default_provider()

    def invoke(self, prompt, model, max_tokens, temperature):
        # Protected by circuit breaker
        provider_response = self.circuit_breaker.call(
            self.provider.invoke,
            prompt=prompt,
            model=model,
            max_tokens=max_tokens,
            temperature=temperature,
        )
        return LLMResponse(...)
```

**Result:** All LLM API calls are automatically protected from cascading failures.

---

## Real-World Scenarios

### Scenario 1: Anthropic API Rate Limited

**Timeline:**

```
t=0s:    Request 1 fails (rate limited)
t=1s:    Request 2 fails (rate limited)
t=2s:    Request 3 fails (rate limited)
t=3s:    Request 4 fails (rate limited)
t=4s:    Request 5 fails (rate limited)
         ⚠️ THRESHOLD EXCEEDED → Circuit opens
t=5s:    Request 6 → CircuitBreakerOpenError (FAST FAIL)
t=6s:    Request 7 → CircuitBreakerOpenError (FAST FAIL)
...
t=30s:   Recovery timeout elapsed → Transition to HALF_OPEN
t=31s:   Probe request succeeds → Circuit CLOSED
t=32s:   Normal operation resumed
```

**Without circuit breaker:** System would waste 1000+ failed retry attempts.  
**With circuit breaker:** Only 5 actual API calls made, 1 probe, fast recovery.

### Scenario 2: Temporary Network Issue

**Timeline:**

```
t=0s-4s:   5 failures (temporary network glitch)
           Circuit OPENS
t=5s-30s:  Requests blocked (OPEN state)
           System uses cache/fallbacks
t=30s:     Probe allowed (HALF_OPEN)
t=31s:     Probe succeeds (network recovered)
           Circuit CLOSED, normal operation
```

---

## Testing

The circuit breaker is fully testable:

```python
# Test CLOSED → OPEN transition
breaker = CircuitBreaker()

for i in range(5):
    try:
        breaker.call(lambda: raise ValueError("API error"))
    except ValueError:
        pass

assert breaker.get_status()["state"] == "open"

# Test OPEN → HALF_OPEN transition
time.sleep(30)
assert breaker.get_status()["state"] == "half_open"

# Test HALF_OPEN → CLOSED transition
result = breaker.call(lambda: "success")
assert breaker.get_status()["state"] == "closed"
```

---

## Performance Characteristics

| Metric | Value |
|--------|-------|
| **State check time** | O(1) |
| **Failure recording** | O(N) where N = failures in window (typically small) |
| **Memory overhead** | ~1KB per breaker instance |
| **Recovery latency** | 30 seconds (configurable) |

---

## Related GADs

- **GAD-510:** Quota Manager (complements with rate limiting)
- **GAD-511:** Provider Strategy (provides fallback when circuit opens)

---

## References

- **Implementation:** `agency_os/00_system/runtime/circuit_breaker.py`
- **Pattern:** Circuit Breaker (Martin Fowler, Release It! by Michael Nygard)
- **State Machine:** Standard 3-state design (OWASP guidelines)

