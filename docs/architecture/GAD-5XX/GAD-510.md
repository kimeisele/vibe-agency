# GAD-510: Operational Quota Manager

**Version:** 1.1 (includes GAD-510.1 - Dynamic Configuration)  
**Status:** âœ… Implemented  
**Location:** `agency_os/00_system/runtime/quota_manager.py`

---

## Executive Summary

Prevents cost spikes and API rate limit violations by enforcing **5 operational quotas**:

1. **Requests per Minute (RPM)** â€” Rate limiting
2. **Tokens per Minute (TPM)** â€” Throughput limiting
3. **Cost per Request** â€” Expensive request protection
4. **Cost per Hour** â€” Hourly spend ceiling
5. **Cost per Day** â€” Daily spend ceiling

**Key Insight:** Pre-flight checks prevent requests that would exceed quotas, saving money and preventing API errors.

**GAD-510.1:** Quotas are **environment-configurable** via Phoenix config or env vars (no code changes needed).

---

## Problem Statement

Without quota enforcement:

1. **Cost surprises** â€” $100 bill for a single bug loop
2. **Rate limit hits** â€” System slammed by too many requests
3. **Runaway processes** â€” No brake on expensive operations
4. **No visibility** â€” Don't know how much spending will happen until it's too late

**Example:** Feature request processing generates 50,000 tokens, hits hourly quota â†’ Error mid-way â†’ Data inconsistency.

---

## Quota Types & Defaults

### Table: Quota Limits

| Quota | Default | Purpose | Config Variable |
|-------|---------|---------|-----------------|
| **RPM** | 10 | Max requests/min | `VIBE_QUOTA_REQUESTS_PER_MINUTE` |
| **TPM** | 10,000 | Max tokens/min | `VIBE_QUOTA_TOKENS_PER_MINUTE` |
| **Cost/Request** | $0.50 | Max per single request | *(hardcoded)* |
| **Cost/Hour** | $2.00 | Max hourly spend | `VIBE_QUOTA_COST_PER_HOUR_USD` |
| **Cost/Day** | $5.00 | Max daily spend | `VIBE_QUOTA_COST_PER_DAY_USD` |

### Default Configuration

```python
@dataclass
class QuotaLimits:
    requests_per_minute: int = 10
    tokens_per_minute: int = 10000
    concurrent_requests: int = 10
    cost_per_request_usd: float = 0.50
    cost_per_hour_usd: float = 2.0
    cost_per_day_usd: float = 5.0
```

---

## GAD-510.1: Dynamic Configuration

### Environment Variables

```bash
# Load quotas from environment (with fallback defaults)
VIBE_QUOTA_REQUESTS_PER_MINUTE=10        # Default: 10
VIBE_QUOTA_TOKENS_PER_MINUTE=10000       # Default: 10,000
VIBE_QUOTA_COST_PER_HOUR_USD=2.0         # Default: $2.00
VIBE_QUOTA_COST_PER_DAY_USD=5.0          # Default: $5.00
```

### Phoenix Config Integration

```python
def _load_quota_limits_from_config() -> dict[str, Any]:
    """
    Load from Phoenix config first, fall back to environment variables.
    
    Priority:
    1. Phoenix Config (if available)
    2. Environment variables
    3. Safe defaults
    """
    if _PHOENIX_AVAILABLE and get_config:
        try:
            config = get_config()
            return {
                "requests_per_minute": config.quotas.requests_per_minute,
                "tokens_per_minute": config.quotas.tokens_per_minute,
                "cost_per_hour_usd": config.quotas.cost_per_hour_usd,
                "cost_per_day_usd": config.quotas.cost_per_day_usd,
            }
        except Exception as e:
            logger.debug(f"Phoenix unavailable, falling back to env vars: {e}")
    
    # Fallback: environment variables
    return {
        "requests_per_minute": int(os.environ.get("VIBE_QUOTA_REQUESTS_PER_MINUTE", "10")),
        "tokens_per_minute": int(os.environ.get("VIBE_QUOTA_TOKENS_PER_MINUTE", "10000")),
        "cost_per_hour_usd": float(os.environ.get("VIBE_QUOTA_COST_PER_HOUR_USD", "2.0")),
        "cost_per_day_usd": float(os.environ.get("VIBE_QUOTA_COST_PER_DAY_USD", "5.0")),
    }
```

**Benefit:** Change quotas via environment variables without modifying code.

---

## Quota Enforcement

### Two-Phase Approach

#### Phase 1: Pre-flight Check (Before Request)

```python
def check_before_request(
    self,
    estimated_tokens: int,
    operation: str = "unknown",
) -> tuple[bool, str]:
    """
    Pre-flight check before sending request to LLM.
    
    Raises QuotaExceededError if any quota would be exceeded.
    """
```

**When to call:**
```python
try:
    quota.check_before_request(
        estimated_tokens=5000,
        operation="feature_implementation"
    )
except QuotaExceededError as e:
    logger.error(f"Cannot execute: {e}")
    return cached_result()  # Use fallback

# Only execute if check passed
response = llm_client.invoke(prompt="...", model="...")
```

**Benefits:**
- Prevents wasted API calls
- Saves costs
- Fail fast before making network requests

#### Phase 2: Recording Usage (After Request)

```python
def record_request(
    self,
    tokens_used: int,
    cost_usd: float,
    operation: str = "unknown",
):
    """
    Record actual token usage and cost after request completes.
    
    Updates rolling windows and logs warnings at 80% of limits.
    """
```

**When to call:**
```python
response = llm_client.invoke(...)

quota.record_request(
    tokens_used=response.usage.input_tokens + response.usage.output_tokens,
    cost_usd=response.usage.cost_usd,
    operation="feature_implementation"
)
```

**Why split into two phases:**
- Pre-flight uses *estimates* (allow some margin)
- Actual recording uses *actuals* (precise tracking)
- Allows system to use better estimates over time

---

## Sequential Quota Checks

The `check_before_request()` runs these checks in order, **failing fast** on first violation:

### Check 1: Request Rate Limit (RPM)

```python
if self.metrics.requests_this_minute >= self.limits.requests_per_minute:
    raise QuotaExceededError(
        f"Request rate limit exceeded: {self.metrics.requests_this_minute}/"
        f"{self.limits.requests_per_minute} RPM"
    )
```

**Prevents:** Too many API calls in short time window.

### Check 2: Token Rate Limit (TPM)

```python
if self.metrics.tokens_this_minute + estimated_tokens > self.limits.tokens_per_minute:
    raise QuotaExceededError(
        f"Token rate limit would be exceeded: "
        f"{self.metrics.tokens_this_minute + estimated_tokens}/"
        f"{self.limits.tokens_per_minute} TPM"
    )
```

**Prevents:** Throughput explosion (e.g., large batch processing).

### Check 3: Per-Request Cost

```python
estimated_cost = self._estimate_cost(estimated_tokens)

if estimated_cost > self.limits.cost_per_request_usd:
    raise QuotaExceededError(
        f"High-cost request: ${estimated_cost:.2f} "
        f"exceeds limit of ${self.limits.cost_per_request_usd:.2f}"
    )
```

**Prevents:** Accidentally expensive single requests ($10+ responses).

### Check 4: Hourly Cost Limit

```python
if self.metrics.cost_this_hour_usd + estimated_cost > self.limits.cost_per_hour_usd:
    raise QuotaExceededError(
        f"Hourly cost limit would be exceeded: "
        f"${self.metrics.cost_this_hour_usd + estimated_cost:.2f}/"
        f"${self.limits.cost_per_hour_usd:.2f}"
    )
```

**Prevents:** Hourly runaway (e.g., broken loop processing all night).

### Check 5: Daily Cost Limit

```python
if self.metrics.cost_this_day_usd + estimated_cost > self.limits.cost_per_day_usd:
    raise QuotaExceededError(
        f"Daily cost limit would be exceeded: "
        f"${self.metrics.cost_this_day_usd + estimated_cost:.2f}/"
        f"${self.limits.cost_per_day_usd:.2f}"
    )
```

**Prevents:** Daily budget overrun.

---

## Rolling Windows

Quotas use **rolling time windows** that reset automatically:

```python
@dataclass
class QuotaMetrics:
    # Minute window (resets every 60s)
    requests_this_minute: int = 0
    tokens_this_minute: int = 0
    minute_start_time: float = field(default_factory=time.time)
    
    # Hour window (resets every 3600s)
    cost_this_hour_usd: float = 0.0
    hour_start_time: float = field(default_factory=time.time)
    
    # Day window (resets every 86400s)
    cost_this_day_usd: float = 0.0
    day_start_time: float = field(default_factory=time.time)
    
    # Totals (never reset)
    total_requests: int = 0
    total_tokens: int = 0
    total_cost_usd: float = 0.0
```

**How it works:**
```python
def _update_rolling_windows(self):
    """Reset windows based on elapsed time"""
    now = time.time()
    
    # Reset minute window if 60s passed
    if now - self.metrics.minute_start_time >= 60:
        self.metrics.requests_this_minute = 0
        self.metrics.tokens_this_minute = 0
        self.metrics.minute_start_time = now
    
    # Reset hour window if 3600s passed
    if now - self.metrics.hour_start_time >= 3600:
        self.metrics.cost_this_hour_usd = 0.0
        self.metrics.hour_start_time = now
    
    # Reset day window if 86400s passed
    if now - self.metrics.day_start_time >= 86400:
        self.metrics.cost_this_day_usd = 0.0
        self.metrics.day_start_time = now
```

---

## Cost Estimation

For pre-flight checks, the system estimates cost based on Claude 3.5 Sonnet pricing:

```python
def _estimate_cost(self, tokens: int) -> float:
    """
    Estimate cost for given tokens.
    
    Pricing:
    - Input: $3 per million tokens
    - Output: $15 per million tokens
    
    Assumption: 50% input, 50% output (conservative estimate)
    """
    input_tokens = tokens // 2
    output_tokens = tokens - input_tokens
    
    input_cost = (input_tokens / 1_000_000) * 3.0
    output_cost = (output_tokens / 1_000_000) * 15.0
    
    return input_cost + output_cost
```

**Why conservative estimate?**
- Pre-flight uses estimated tokens
- Actual usage may differ
- Conservative margin prevents surprises

---

## Exceeding Quotas

### What Happens

1. **check_before_request() raises QuotaExceededError**
   ```python
   try:
       quota.check_before_request(estimated_tokens=10000)
   except QuotaExceededError as e:
       logger.error(f"Quota exceeded: {e}")
       # Use fallback strategy
   ```

2. **Request is never sent** to LLM API
   - Saves cost
   - Saves API quota
   - Prevents cascading errors

3. **Error message is detailed:**
   ```
   QuotaExceededError: Daily cost limit would be exceeded: 
   $5.12/$5.00. Request cost: $0.24
   ```

### Logging & Warnings

The system logs warnings at **80% of limits**:

```python
# After recording request
if self.metrics.cost_this_hour_usd > self.limits.cost_per_hour_usd * 0.8:
    logger.warning(
        f"Hourly cost at 80% of limit: "
        f"${self.metrics.cost_this_hour_usd:.2f}/"
        f"${self.limits.cost_per_hour_usd:.2f}"
    )
```

**Provides:** Early warning before hard limits are hit.

---

## Usage Pattern

### Basic Usage

```python
from agency_os.00_system.runtime.quota_manager import (
    OperationalQuota,
    QuotaLimits,
    QuotaExceededError,
)

# Initialize with defaults (from env vars)
quota = OperationalQuota()

# Or initialize with custom limits
quota = OperationalQuota(
    limits=QuotaLimits(
        requests_per_minute=50,
        tokens_per_minute=50000,
        cost_per_hour_usd=10.0,
        cost_per_day_usd=100.0,
    )
)

# Pre-flight check
try:
    quota.check_before_request(
        estimated_tokens=5000,
        operation="document_generation"
    )
except QuotaExceededError as e:
    logger.error(f"Quota exceeded: {e}")
    return cached_result()

# Execute request
response = llm_client.invoke(...)

# Record actual usage
quota.record_request(
    tokens_used=response.usage.total_tokens,
    cost_usd=response.usage.cost_usd,
    operation="document_generation"
)
```

### Monitoring

```python
# Get current quota status
status = quota.get_status()

# Check minute quotas
print(f"RPM: {status['requests']['this_minute']}/"
      f"{status['requests']['limit']}")
print(f"TPM: {status['tokens']['this_minute']}/"
      f"{status['tokens']['limit']}")

# Check cost quotas
print(f"Hour: ${status['cost']['this_hour_usd']}/"
      f"${status['cost']['limit_per_hour_usd']}")
print(f"Day: ${status['cost']['this_day_usd']}/"
      f"${status['cost']['limit_per_day_usd']}")

# Check totals
print(f"Total cost: ${status['cost']['total_usd']}")
print(f"Total requests: {status['totals']['total_requests']}")
```

### Custom Quotas

```python
# Set high quotas for production
prod_limits = QuotaLimits(
    requests_per_minute=1000,
    tokens_per_minute=1_000_000,
    cost_per_hour_usd=500.0,
    cost_per_day_usd=5000.0,
)
quota = OperationalQuota(limits=prod_limits)

# Set low quotas for development
dev_limits = QuotaLimits(
    requests_per_minute=10,
    tokens_per_minute=10_000,
    cost_per_hour_usd=2.0,
    cost_per_day_usd=5.0,
)
quota = OperationalQuota(limits=dev_limits)
```

---

## Integration with LLM Client

The `LLMClient` automatically enforces quotas:

```python
class LLMClient:
    def __init__(self, budget_limit=None, provider=None):
        self.quota_manager = OperationalQuota(
            limits=QuotaLimits(
                requests_per_minute=100,
                tokens_per_minute=100_000,
                cost_per_request_usd=0.50,
                cost_per_hour_usd=50.0,
                cost_per_day_usd=500.0,
            )
        )
    
    def invoke(self, prompt, model, max_tokens, temperature):
        # 1. Pre-flight check
        try:
            self.quota_manager.check_before_request(
                estimated_tokens=max_tokens,
                operation=f"invoke({model})"
            )
        except QuotaExceededError:
            raise  # Re-raise to prevent invocation
        
        # 2. Execute (protected by circuit breaker)
        response = self.circuit_breaker.call(
            self.provider.invoke,
            prompt=prompt,
            model=model,
            ...
        )
        
        # 3. Record actual usage
        self.quota_manager.record_request(
            tokens_used=response.usage.total_tokens,
            cost_usd=response.usage.cost_usd,
            operation=f"invoke({model})"
        )
        
        return LLMResponse(...)
```

---

## Configuration Examples

### Development Environment

```bash
# .env.development
VIBE_QUOTA_REQUESTS_PER_MINUTE=10
VIBE_QUOTA_TOKENS_PER_MINUTE=10000
VIBE_QUOTA_COST_PER_HOUR_USD=2.0
VIBE_QUOTA_COST_PER_DAY_USD=5.0
```

### Production Environment

```bash
# .env.production
VIBE_QUOTA_REQUESTS_PER_MINUTE=1000
VIBE_QUOTA_TOKENS_PER_MINUTE=1000000
VIBE_QUOTA_COST_PER_HOUR_USD=500.0
VIBE_QUOTA_COST_PER_DAY_USD=5000.0
```

### Shared Testing

```bash
# .env.test
VIBE_QUOTA_REQUESTS_PER_MINUTE=100
VIBE_QUOTA_TOKENS_PER_MINUTE=100000
VIBE_QUOTA_COST_PER_HOUR_USD=50.0
VIBE_QUOTA_COST_PER_DAY_USD=500.0
```

---

## Real-World Scenarios

### Scenario 1: Preventing Cost Spike

**Setup:** Daily quota = $5.00

**Timeline:**
```
11:00am: 1 request, cost $0.24 â†’ Total: $0.24 (4.8% of daily)
12:00pm: 5 requests, cost $1.20 â†’ Total: $1.44 (28.8% of daily)
1:00pm:  10 requests, cost $2.40 â†’ Total: $3.84 (76.8% of daily)
         âš ï¸ 80% warning logged
2:00pm:  15 requests â†’ Estimated cost $3.60
         ðŸ’¥ Daily quota check: $3.84 + $3.60 > $5.00
         âœ‹ QuotaExceededError raised
         ðŸ“Œ Request blocked, no API call made
2:01pm:  System handles error, uses cache for some requests
```

**Without quota manager:** System would make API call, incur charge, then fail.  
**With quota manager:** Error caught before API call, cost avoided.

### Scenario 2: Rate Limiting Protection

**Setup:** RPM quota = 10

**Timeline:**
```
t=0s:  Request 1 â†’ OK (1/10 RPM)
t=1s:  Request 2 â†’ OK (2/10 RPM)
t=2s:  Request 3 â†’ OK (3/10 RPM)
...
t=9s:  Request 10 â†’ OK (10/10 RPM)
t=10s: Request 11 â†’ ðŸ›‘ QuotaExceededError
       "Request rate limit exceeded: 10/10 RPM"
t=60s: Minute window resets
       Request 12 â†’ OK (1/10 RPM)
```

**Prevents:** System from hammering API too fast.

---

## Performance

| Metric | Value |
|--------|-------|
| **Check time** | O(1) |
| **Record time** | O(1) |
| **Memory** | ~500 bytes per quota manager |
| **Reset latency** | < 1ms |

---

## Related GADs

- **GAD-509:** Circuit Breaker (complements with cascading failure prevention)
- **GAD-511:** Provider Strategy (uses quotas for all providers)

---

## References

- **Implementation:** `agency_os/00_system/runtime/quota_manager.py`
- **Config:** `agency_os/config/phoenix.py` (Phoenix config integration)
- **Pattern:** Token Bucket / Sliding Window Rate Limiting

